# 《操作系统》复习提纲

## 操作系统概论

### 计算机系统

#### 含义

硬件、操作系统、应用程序和用户

#### 层次结构

##### 硬件层

处理器，存储器，I/O设备

操作系统程序员

##### 操作系统层

程序员

##### 系统程序层

编译器，数据库系统

程序员

##### 应用层

面向特定用户的应用的软件

用户

### 什么是操作系统

#### 扩展机器——抽象与模拟

一个程序，充当计算机用户和硬件之间的媒介，为用户提供一个环境，以遍历和有效的方式运行程序

##### 抽象

###### 设备——文件

###### +存储——虚拟存储

###### +处理器——进程

##### 虚拟

每个应用运行在一台虚拟机上

#### 资源管理——保护与复用

管理系统资源，控制程序执行，改善人机界面，提供各种服务，合理组织计算机工作流程，为用户有效使用计算机提供良好运行环境的一种系统软件

##### 保护

防止应用程序干扰，保证独立性

##### 复用

###### 时分复用

###### 空分复用

### 操作系统的任务

#### 自顶向下

为应用开发人员提供简洁易用的资源抽象

#### 自底向上

管理种类繁多，纷繁复杂的硬件资源

### 操作系统的功能

#### 资源管理

#### 控制执行

#### 提供接口

### 操作系统的目标

#### 用户——方便用户使用

#### 机器——提升机器能力

#### 效率——提高运行效率

### 操作系统的主要特征

#### 并发性

##### 并发性

两个及两个特上的事件或活动在同一时间间隔内发生

###### 多任务系统

支持并发的操作系统

##### 并行性

两个或以上得时间在同一时刻发生

并行是并发更严格得特例

#### 共享性

系统中的资源可以被多个并发执行得任务所使用

##### 共享方式

###### 互斥访问

###### 同时访问

#### 异步性

任务执行的时间，推进速度不定——确保任务正确执行

事件发生的不可预期——能够处理事件

#### 虚拟性

管理技术

物理上的一种实体变成逻辑上的多个对应物

物理上的多种实体变成逻辑上的一个对应物

### 计算机的引导过程

BOIS（基本输入输出系统，检查硬件，通过int提供服务） -> bootloader（一阶段：Master Boot Recorder 主引导 扇区，0号扇区，二阶段：LILO选择操作系统） -> kernel -> （Userspace）init（1号进程，由内核凭空构造出来）

### 操作系统基本形态

#### 代码

系统调用服务

中断处理代码

进程调度代码

#### 队列

Long-term queue

Short-term queue

操作系统代码如何获得主导地位

区分核心态和用户态（通过指令集）

主存保护机制

### 用户代码的切换

#### 指令

##### 用户态

call & ret

##### 内核态

中断 & iret

（暂存寄存器信息）

#### 切换场景

###### 系统调用

###### 时钟中断

###### 设备中断

### 操作系统的发展阶段

#### 手工操作阶段

#### 管理程序阶段

批处理形式，单道程序设计

### 多道程序设计

#### 多道批处理系统

##### 目标

提高系统资源利用的效率（输入，输出，处理器）

##### 实现

引入了较弱的独立的I/O处理器，达到并行的目的

##### 特点

提高了效率

但延长了计算时间，牺牲了用户的响应时间

可以储存多个任务

##### 利用率的计算

$$
CPU利用率= 1 - p^n(p是程序I/O操作的时间比例，n是多道程序的道数)
$$



#### 分时系统——CTSS

##### 目的

多个用户共享时，较快响应用户的命令

### 实现

时间轮片的方式共享CPU

### 操作系统的分类

#### 批处理操作系统

##### 特点

成批处理作业

#### 分时操作系统

#### 实时操作系统

在规定的时间限制内完成响应和处理

##### 硬实时

所有

##### 软实时

大部分完成



### 操作系统提供的服务

创建程序，执行程序，数据输入输出，信息存取，通信服务，错误检测和处理

资源分配，统计，保护

### 操作系统提供的接口

#### 用户接口

##### 字符接口——shell

##### 图形界面

#### 程序接口——API

API和系统调用的辨析：系统调用以API的形式提供，但是API程序未必需要进行系统调用

API可以通过系统调用，库函数等形式实现，可以使用一个或者多个系统调用

##### 系统程序、库函数、系统调用的分层关系

用户接口->库函数接口->系统调用接口->（进入内核态）操作系统

i.e.fprintf->wirte->系统调用->sys_write

####  系统调用

应用程序请求内核操作系统服务的过程

通过访管指令开始

### 操作系统结构

#### 基本元素

##### 内核

提供支持系统运行的基本单位和基本操作

##### 进程

资源分配和调度的单位

##### 线程

调度单位

#### 内核

#### 分类

##### 整体式结构

联系紧密，结构不清晰

##### 层次式结构

操作员，用户程序，输入/输出管理，操作员控制台-进程通行，内存管理，处理器分配

功能独立，通信开销大

##### 虚拟机结构

##### C/S及微内核结构

策略与机制的分离

用户进程和服务器进程形成CS关系

服务器进程完成操作系统的大部分功能

内核只完成必要的极少的功能，包括进程调度和通信

可移植性好但是运行效率低（通行开销较大）

### 操作系统运行模型

#### 宏内核模型

操作系统服务例程嵌入应用进程模型

使用用户进程的核心栈

无需进行两次进程切换

#### 微内核模型

操作系统服务例程作为独立进程运行模型

通过微内核的消息传递机制传递应用进程的服务请求和服务器进程的服务响应

模块化有利于操作系统的更新

适用于分布式系统

## 处理器管理

### 定义

负责管理、调度和分派处理器，控制程序执行

#### 处理器分配

#### 进程调度

### 处理器

#### 内部组成

###### 控制器

###### 运算器

###### 寄存器

###### 中断装置

###### 输入/输出电路

###### 高速缓存

#### 处理器状态

##### 目标

对应特权指令的执行权限

##### 管理状态

特权状态，系统状态，特态，管态，执行所有指令

##### 用户状态

目标状态，用户模式，常态，目态，执行非特权指令

##### 状态转换

中断和系统调用



### 机器指令

#### 指令

计算机执行某些操作的命令

#### 指令系统

计算机所有指令的集合

RISC，CISC

特权指令，非特权指令

### 程序状态字

#### 目的

区分不同程序的处理器工作状态

#### 存储

处理器寄存器

#### 主要内容

##### 程序基本状态

程序计数器，条件码，状态位（eip , eflags）

##### 中断码

##### 中断屏蔽位

### 中断技术

#### 含义

向CPU报告已完成某项操作

在发生某个事件时，中止现行程序，引出服务处理程序

#### 实现

需要硬件和软件配合完成

#### 中断源

引起中断的事件

##### 分类

###### 内/外中断

处理器和主存为内，其他为外

### 中断装置

发现中断源并产生中断的硬件

#### 作用

捕获和产生中断

保护现场

启动中断处理程序

#### 过程

中断源->中断装置->写入中断寄存器->中断控制部件->中断处理程序

### 中断处理程序

#### 功能

##### 保护现场信息

##### 识别中断源

##### 处理中断事件

##### 中断恢复

### 中断处理过程

硬件

1、发现中断源

2、保护现场

3、转入中断处理程序

软件

4、保护现场

5、中断处理代码

6、调度

7、恢复现场

硬件

8、恢复现场

### 中断的优先级

同时发生中断事件时的响应顺序

#### 中断屏蔽

高优先级中断的过程中可以屏蔽低优先级的中断

（有的中断不可以屏蔽，比如访管中断）

### 多重中断事件

中断处理中出现了新的中断

#### 串行处理

处理过程中关中断

#### 嵌套处理

开中断，执行更高优先级的中断程序

#### 即时处理

中断处理中发生的程序性中断

### 慢中断/块中断

#### 慢中断

分为上半部分和下半部分，上半部分关中断，下半部分进入排队调度

保存所有寄存器的值，不关中断，处理后转入调度程序

#### 快中断

仅保存被使用的寄存器的值，关中断，转入原进程

### 信号机制

#### 软件中断

一种模拟硬件中断的简单通信机制

内核->进程

进程->进程

#### 系统调用

##### signal

注册信号

##### kill

发送信号

#### signal表

在用户进程存储，由os查询使用

### 进程

#### 概念

##### 理论角度

进程是对正在运行的**程序活动规律**的**抽象**

##### 实现角度

刻画**程序运行状态**和系统动态变化的**数据结构**

#### 目的

##### 并发性

并发程序设计的工具——并发性

##### 共享性

标识程序的多次运行——共享性

###### 可重入（再入）程序

只有代码部分共享

调用方提供工作区

区分：可重入只有代码可以共享，不修改数据，线程安全函数可以修改全局变量

#### 定义

进程是一个**可并发执行**的**具有独立功能**的程序关于**某个数据集合**的一次执行过程，是操作系统进行**资源分配和保护**的**基本单位**

#### 性质

###### 共享性

###### 动态性

###### 独立性

###### 制约性

###### 并发性

#### 进程的状态和转换

##### 三态模型

###### 运行态

进程在cpu上运行

###### 就绪态

只需要等待cpu资源

###### 等待态

等待某个事件

#### 

##### 五态模型



##### <img src="C:\Users\武毛毛\AppData\Roaming\Typora\typora-user-images\image-20220621101655826.png" alt="image-20220621101655826" style="zoom:50%;" />

#### 挂起状态

讲进程对换到外部存储器上，释放占用的资源，排除在进程调度之外

##### 目的

提高资源利用率，减轻负担

调试程序，排除故障

##### 具有挂起状态的状态转换模型

注意OS依然负责挂起等待态的事件处理，所以管理的数据结构依然在内存中

<img src="C:\Users\武毛毛\AppData\Roaming\Typora\typora-user-images\image-20220621102029679.png" alt="image-20220621102029679" style="zoom:50%;" />

#### 进程的内存映像

| 进程控制块（PCB）                      |
| -------------------------------------- |
| **核心堆栈（OS代码执行的空间）**       |
| **用户堆栈**                           |
| **用户私有地址空间（代码段，数据段）** |
| **共享地址空间**                       |

#### 进程的上下文

##### 内容

进程物理实体

支持进程运行的环境

##### 类型

###### 用户级上下文

程序段，数据段，共享存储区，用户栈

###### 寄存器上下文

程序状态字寄存器，栈指针寄存器，通用寄存器

###### 系统级上下文

进程控制块，主存管理信息（页表，段表），核心栈

#### 进程控制块

进程存在的唯一标识，记录和刻画进程状态及环境信息的数据结构

只能由操作系统内核来使用和修改

##### 结构

###### 进程标识信息

外部标识（signal）

内部标识（pid）

###### 进程现场信息——寄存器

通用寄存器，PSW，控制寄存器

###### 进程控制信息——调度相关

进程的状态，通讯信息，资源清单（已打开文件表）

#### 进程队列

##### 含义

处于同一状态的所有**进程控制块**链接在一起的数据结构

##### 状态转换

就绪队列，等待队列

##### 实现

链接方式

索引方式

####  进程上下文切换（进程切换）

进程调度/进程切换

#### 处理器状态切换（模式切换）

用户态/核心态

#### 进程切换和模式切换

进程切换必然引发模式切换

模式切换未必以为进程切换，中断驱动

#### 用户进程和系统进程

用户进程和系统进程对应一个进程的两个侧面，对应的是一个PCB

##### 用户进程

用户态，用户代码

##### 系统进程

核心态，操作系统代码

### 进程控制的内容

#### 进程创建

##### 原语

###### fork——父子关系

派生

###### clone——对等关系

克隆

##### 过程

1、申请PCB

2、分配进程映像空间

3、分配资源

4、将进程装入分配空间

5、初始化PCB，分配唯一标识

6、加入就绪队列/直接运行

7、通知操作系统其它模块

#### 进程阻塞和唤醒

##### 原语

###### wait

###### waitpid

###### sleep

###### eg.write

##### 进程阻塞

1、PCB保存现场信息

2、等待态

3、等待队列

4、调度程序

##### 进程唤醒

1、取出PCB

2、恢复就绪态

3、加入就绪队列

#### 进程撤销（终止）

##### 原语

###### exit

##### 原因

完成/异常

##### 过程

1、找到PCB

2、进程资源归还父进程/系统

3、撤销子进程

4、PCB归还

### 线程

#### 原因

以进程为单位的并发程序设计效率不高

1、时空开销大（频繁调度）

2、通行代价高

3、并发粒度大

#### 策略

将独立分配资源和分派调度分离

#### 定义

操作系统中独立执行的实体，资源调度和分配的基本单位

轻量级进程

同一进程中的线程共享主存空间和资源

#### 状态转换

三态模型

#### 线程的结构

##### 线程控制块（TCB）

程序计数器

寄存器

堆栈信息

状态

##### 用户堆栈

##### 系统堆栈

#### 线程的组织

##### 调度员—工作者模式

一个线程担任调度员，接收和粗粒工作请求，唤醒工作者线程

##### 组模式

每个线程都可以取得并处理请求，每个线程专门处理对应的请求

##### 流水线模式

线程拍成某个次序，数据按照排定顺序在线程一次传递

#### 线程的管理

##### 创建——thread_create

##### 等待——thread_join

##### 出让——thread_yield

##### 终止——thread_exit

#### 线程的实现方式

##### 内核级实现——KLT

###### 优点

多个处理器上执行多个线程，一个线程被阻塞不会影响其它的线程

###### 缺点

切换代价高，两次模式切换



##### 用户级实现——ULT

###### 优点

切换代价低

调度算法实现灵活

###### 缺点

同一进程的多个线程不能在多个处理器上运行

一个线程的阻塞将导致整个进程阻塞

非抢占式调度

##### 混合实现

#### 实现方式

<img src="C:\Users\武毛毛\AppData\Roaming\Typora\typora-user-images\image-20220621114943795.png" alt="image-20220621114943795" style="zoom:50%;" />

#### 多线程并发程序设计的优点

1、易于通信——通信开销大

2、管理开销低——调度代价高

3、**I/O密集型性能更好**

4、更好的利用多处理器——并发粒度大

### 处理器调度

挑选作业进入内存

#### 分类

##### 高级调度（作业调度，长程调度）

作业管理，提交，终止

###### 多道批处理系统

**后备作业**->进程

作业准备->启动->终止善后

###### 分时系统

终端连接

交互作业

##### 中级调度（平衡负载调度、中程调度）

进入内存

挂起和解决挂起

控制存储器中容纳的进程数，保证合理数目的进程间处理器和相关资源

##### 低级调度（线程调度，短程调度）

占用处理器

指派分配

###### 抢占方式

+ 优先级剥夺

+  限时剥夺

###### 非抢占方式

###### 剥夺/非剥夺方式

剥夺方式开销大于非剥夺方式，但可以比避免长时间独占处理器

<img src="C:\Users\武毛毛\AppData\Roaming\Typora\typora-user-images\image-20220621115414058.png" alt="image-20220621115414058" style="zoom:50%;" />

### 调度算法

#### 调度算法的评估因素

##### 资源利用率

CPU有效工作时间/总运行时间

##### 响应时间——分时系统、实时系统

从作业提交到回应的时间

##### 周转时间——批处理系统

作业提交到完成的时间

##### 吞吐率

单位时间内处理的作业数

##### 公平性

获得合理的份额，不会饿死

#### 典型的作业调度算法

##### 先来先服务（FCFS：First come first serve）

按照进入后备序列的先后顺序挑选作业

效率低，有利于长作业

##### 最短作业优先算法（SJF：shortest job first）

挑选CPU最短时间的作业

效率高，难以预测运行时间

长作业饥饿

##### 最短剩余时间优先（SRTF：shortest rest time first）

SJF的抢占版本

选择剩余运行时间最短

效率较高，饿死长作业

##### 响应比最高优先算法（HRRF：Highest Response Ratio First）

防止了饥饿

###### 响应比

后备队列等待时间 + 运行时间 / 作业估计计算时间

= 等待时间 / 估计计算时间 + 1

=（前一个任务完成时间 - 作业提交时间）/ 作业执行时间  + 1

#### 典型的低级调度算法

##### 先来先服务

###### 实现

使用就绪队列

###### 特点

非抢占式调度

对I/O频繁的程序不友好

##### 时间片轮转

###### 实现

时钟中断，轮流执行

不主动出让处理器的进程（计算密集型）被抢占下来放在就绪队列队尾

###### 特点

抢占式调度

##### 分类

###### 基本时间片轮转法——时间片相同

###### 动态时间片轮转法——时间片不同

##### 时间片的选取

太长——FCFS

太短——调度频繁

##### 优先数调度算法

###### 实现

优先数最大的进程执行

###### 特点

抢占式和非抢占式

###### 分类

###### 静态优先数

###### 动态优先数

连续占用处理器越长，优先数越小

等待时间越长，优先数越大

+ 动态优先数的计算

  开销较大，要在合理的时候计算

##### 最短进程优先

下次执行的时间最短者优先

有利于区分I/O密集型和计算密集型进程

###### 下次持续时间的计算

老化算法：利用历史行为预测
$$
aT_0 + (1 - a)T_1 = T_2
$$


##### 多级反馈队列调度（反馈队列调度/多队列策略）

将就绪队列划分为多级队列，高队列优先级高，时间片短

I/O密集型高优先级队列

计算密集型低优先级队列

同一队列FCFS

###### 静态分级

作业提交以后判断I/O密集型和计算密集型分级

###### 动态分级

如果没有用完时间片，就回到原来的时间片

<img src="C:\Users\武毛毛\AppData\Roaming\Typora\typora-user-images\image-20220621125501004.png" alt="image-20220621125501004" style="zoom:50%;" />

##### 保证调度算法

向用户做出明确的性能保证

###### 实现

计算实际获得CPU时间和应得到的CPU时间之比，转向最低的进程

##### 彩票调度算法

随机选择一张彩票

进程持有的彩票越多，获得资源的可能性越大

###### 特点

有利于协作

如果A，B依赖C进程，A和B可以把彩票送给C

### 实时系统的调度

#### 要求

响应时间可预期，在规定的时间内可以处理完对应进程的工作

#### 可调度

Ci为执行时间，Pi为周期长度

比如100ms执行，200ms周期，则为0.5
$$
\sum{C_i \over Pi} \le 1
$$

#### 典型的实时调度算法

##### 单比率调度算法

频率越高的事件，优先级最高（静态）

1次/s和1次/5s，那么选前一个

##### 限期调度算法

截至期限越近，先调度

##### 最少裕度调度算法

裕度 = 截至时间 - （就绪时间 + 执行时间）

### 批处理作业的管理与调度

#### 作业的生命周期

提交、收容、执行（中、低级调度）和完成

输入状态（从低速设备读入高速设备）->后备状态->创建进程执行->完成状态（将高速设备的数据写入低速设备）

#### 目标

平均周转时间小，接近于作业执行时间



## 并发控制

### 顺序程序设计

#### 定义

##### 程序内部

将程序设计为顺序执行的程序模块

##### 程序之间

不同程序之间也是按顺序执行

#### 特点

##### 执行——顺序性

内部顺序性，外部顺序性

##### 环境——封闭性

独占全机资源

##### 结果——确定性

##### 计算过程——可再现性

#### 优点

程序编制、调试方便

#### 缺点

效率低

### 并发程序设计

#### 定义

将一个程序分成若干个可同时执行的程序模块

每个程序模块和它所处理的数据组成了进程

#### 特点

##### 并发性

一组进程在执行时间上重叠：一个进程的第一条指令在另一个进程执行的最后一条指令完成之前开始

###### 宏观

一个时间段中几个进程同时处于活动状态

###### 微观

任一时刻有且仅有一个进程在cpu上运行

###### 实质

CPU的多个进程中的多路复用

##### 共享性

##### 制约性

##### 交互性

###### 竞争关系（间接制约）——进程互斥

任何时刻只允许至多一个进程访问

###### 协作关系（直接制约）——进程同步

基于某个条件来协调活动，具体通过协作进程的消息或者信号来协调

###### 互斥关系是一种特殊的同步关系

协作关系是主动意识到的等待

竞争关系是因为争抢资源引发的等待

#### 优点

##### 单处理器系统

处理器和I/O设备同时工作

提高硬件并行度

##### 多处理器系统

各进程并行执行

加快计算速度

##### 简化程序设计任务

### 并发进程之间的关系

#### 无关

一组并发进程分别在不同的**变量集合**上操作，一个进程的执行和其他进程执行的进度无关

##### 无关的并发进程的判断——Bernstein条件

$$
R_1 \cap W_2 \cup W_1 \cap R_2 \cup W_1 \cap W_2 
$$

则并发进程的执行与时间无关

#### 交互

一组并发进程**共享某些变量**，一个进程的执行可能影响其他进程的结果

##### 带来的问题

由于执行相对速度无法控制

###### 结果不唯一

###### 永远等待

进程因为判断之后没有来得及进入等待队列错失了被唤醒的机会

### 临界区管理

#### 临界区

并发进程中与共享变量有关的程序段

#### 临界资源

共享变量代表的资源

#### 临界区管理

保证一个进程在临界区执行时，不让另一名进程进入相关的临界区——共享变量的互斥访问

#### 临界区调度的原则

##### 至多一个

一次至多一个进程能够进入临界区

##### 有限进入

不能让一个进程无限留在临界区

##### 不允许无限等待

不能强迫一个进程无限等待进入临界区

##### 无空等待，有空让进，择一而入，算法可行

#### 临界区的描述

##### 临界资源（共享变量）——shared

$$
shared \ 变量名
$$

##### 临界区

指的是关于共享变量的临界区
$$
region \ 变量名 \ do \ \{语句\}
$$

###### 临界区嵌套

可能出现死锁

#### 临界区管理的尝试

##### 先测试，后置位

不能保证同一时间只有一个进程进入临界区

都进去了才置位

##### 先置位，后测试

永远等待

A等B放，B等A放

### 临界区管理软件方法

#### Dekker算法

##### 基本思想

先置位+指示器turn

如果双方都想进入临界区咨询指示器

执行完毕后让出指示器

```pascal
var inside: array[1..2] of boolen;
turn :integer;
turn := 1 or 2;
inside[1] := false;
inside[2] := false;

cobegin
process P1
begin
	inside[1] := true;
	while inside[2] do
		inside[1] := false;
		while turn = 2 do begin end;//只关心指示器
		inside[1] := true;
	end
	临界区
	turn := 2;
	inside[1] := false;
end
```



#### Peterson算法

##### 基本思想

先置位+谦让指示器

```Pascal
var inside: array[1..2] of boolean;
turn :integer;
turn:= 1 or 2;
inside[1] := false;
inside[2] := false;
cobegin
process P1
begin
	inside[1] = true;
	turn := 2;
	while(inside[2] and turn = 2)//关心临界资源和指示器
		do begin end;
	临界区
	inside[1] := false;
end
```

### 临界区管理硬件方法

常用于解决内核代码的临界区管理问题

只有实现了内核代码的临界区管理问题，才能保证全局变量的互斥访问，才能解决用户代码的临界区管理的问题

#### 关中断——单cpu

##### 特权指令

##### 单cpu上有效

不能解决并行问题

##### 是内核上处理临界区问题的高效方法

#### 自旋锁——多cpu

通过TSL和XCHG实现的机制称为自旋锁

常用来解决内核临界区管理

#### 测试并设置指令(TSL)

把测试和设置在一个指令中实现，不会被中断

完成两个任务，将内存中LOCK的值取到寄存器中，并且将LOCK置为1

```assembly
enter_region:
	
	TSL REGISTER,LOCK
	CMP REGISTER, #0
	JNE enter_region
	RET

leave_region:
	MOVE LOCK,#0
	RET
```

#### 对换指令（XCHG）

更加通用的TSL实现角度

```pascal
var lock :boolean
lock := false
process Pi
var pi : boolen
begin
	pi := true;
	repeat Swap(lock, pi) until pi = false;
	临界区;
	lock := false;
end
```

### 进程同步机制

#### 定义

操作系统通过实现相应的进程同步机制，通过系统调用提供给应用程序开发者用于解决同步问题

#### 常见的进程同步机制

##### 信号量与PV操作

##### 管程

##### 消息传递

#### 同步问题

##### 生产者—消费者问题

计算机操作系统中并发进程内在关系的一种抽象，进程同步问题

###### 生产者

计算进程，发送进程

###### 消费者

打印进程，接收进程

###### 问题描述

由n个生产者和m个消费者，连接在一个有k个单位缓存区的有界环形缓存上，其中$p_i$和$c_i$是并发进程。

只要缓存区不满，生产者生产的产品就可以投入缓存区

只要缓存区不空，消费者就可以从缓存区取走产品

###### 存在的问题

+ 缓存区指针

多个生产者或者消费者共用指针，可能会出现结果不唯一的问题

+ 错过等待唤醒

  sleep/wakeup

### 信号量与PV操作

软件方法：编程负担重

硬件方法：忙等待，浪费cpu时间

#### 信号量的分类

##### 用途

###### 公用信号量——进程互斥

**多个进程**可以执行P操作，观察这个信号量

###### 私有信号量——进程同步

只有**个别进程**进行P操作，观察这个信号量

##### 取值

###### 二元信号量——互斥问题

0 or 1

节约内存，可以包装为一般信号量

###### 一般信号量——同步问题

##### 结构

###### 整型信号量

概念上的实现

P(s)

```pascal
while s <= 0 do null operation
s := s - 1
```

V(s)

```pascal
s := s + 1
```

###### 记录型信号量（结构体信号量）

**内核实现**

不仅记录信号量的值，而且需要**记录哪些进程等待在这个信号量的队列**上

+ 分量

  + value，整型量，非负初值
  + queue,进程队列，初值为空（插入pcb）

+ P(s)

  s -= 1, 如果结果小于0，进程将被置于等待信号量s的状态，加入queue

  ```pascal
  Procedure P(var s:semaphore);
  begin
  	s.value := s.value - 1;
  	if s.value < 0 then W(s.queue);
  end
  ```

+ V(s)

  s+= 1，如果结果不大于0，唤醒队列中等待的进程

  ```
  Procedure V(var s:semaphore);
  begin
  	s.value := s.value + 1;
  	if s.value <= 0 then R(s.queue);
  end
  ```

+ **推论**

  + s.value > 0

    表明还可以使用的物理资源的数量

  + s.value < 0

    表明s.queue队列中等待该资源的进程数目

  + P请求一个资源——被阻塞

    V释放一个资源——唤醒被阻塞的进程

#### 二元记录型信号量实现一般性记录型信号量

```
typedef struct semaphore{
	int value;
	binary_semaphore wait,mutex;
	wait := 0;mutex := 1;
}
Semaphore S;
P(S):
	BP(S.mutex);
	S.value--;
	if (S.value < 0){
		BV(S.mutex);
		BP(S.wait);
	}BV(S.mutex);
V(S):
	BP(S.mutex)
	S.value++;
	if (S.value <= 0){
		BV(S.wait);
	}else BV(S.mutex);
```



### 信号量与PV操作解决问题

#### 互斥问题

解决互斥问题的一般框架

```pascal
var mutex: semaphore;
mutex := 1;
cobegin
...
	Process Pi
		begin
		...
		P(mutex);
		临界区
		V(mutex);
		...
		end
coend;
```

#### 售票问题

```Pascal
var A:Array[1..m] of integer;
var s:Array[1..m] of semaphore;
s[j] := 1;
cobegin
..
	Process Pi
	var Xi:integer;
	begin
		L1:
		找到A[j];
		P(s[j]);
		Xi = A[j];
		if Xi >= 1 then
		begin
			Xi := Xi - 1;A[j] = Xi;
			V(s[j]);
			输出票;
		end
		else
		begin
			V(s[j]);
			票已售完;
		end
	goto L1;
	end
coend;
```

#### 哲学家吃通心粉问题

```Pascal
Var s:Array fork[1..n] of semaphore;
s[i] = 1;
cobegin
	process Pi
	begin
		thinking;
		P(fork[i]);
		P(fork[(i + 1) % n)];
		eating;
		V(fork[i]);
		V(fork[(i + 1) % n)];
	end 
coend
```

##### 死锁解决

最多四个热能吃

奇数拿左边，偶数拿右边

只有取到两把才吃，否则不吃

#### 同步问题

信号量此时表明同步问题中是否存在可以被使用的资源的个数

#### 生产者—消费者问题

#### 单个生产者和单个消费者问题

##### 信号量

###### buf

缓存区剩余空间资源

###### product

已存在的产品资源

##### 进程

###### 生产者

生产，P(buf)，放入产品，V(product)

###### 消费者

P(product)，取出产品，V(buf)，消费

#### 多个生产者和多个消费者问题

##### 需要解决的问题

###### 同步问题

生产者和消费者的同步问题

###### 互斥问题

生产者之间互斥使用in指针的问题

消费者之间互斥访问out指针的问题

###### 互斥信号量的P操作总会在后面执行

#### 多类产品的多生产者和多消费者问题

##### 信号量

###### sp：允许放入盘子的长度

###### sg1：可以消费的第一类产品

###### sg2：可以消费的第二类产品

##### 进程

###### 消费者

P(sg1)->取产品->V(sp)

###### 生产者

P(sp)->放产品->V(sg1)

#### 读者—写者问题

##### 信号量

###### readcount

读进程计数器

###### wr

（读写锁）数据访问权限

###### mutex

互斥访问readcount信号量

##### 读者优先的算法

读写数据的时效性也会损失

```pascal
var readcount:integer;
var wr,mutex:semaphore;
readcount := 0;
wr := 0;
mutex := 1;

procedure read
begin
	P(mutex);
	readcount := readcount + 1;
	if readcount = 1 then P(wr);
	V(mutex);
	读文件;
	P(mutex);
	readcount := readcount - 1;
	if readcount = 0 then V(wr);
	V(mutex);
end

procedure write
begin
	P(wr);
	写文件;
	V(wr);
end
```

##### 公平的读者—写者问题

在读着映入计数信号量，最多可以读n次

在写者引入循环，每次拿到读写互斥锁之前要读n次

#### 理发师问题

##### 信号量

###### customer

是否有人需要理发

###### harbars

是否有理发师可以理发

###### mutex

互斥访问waiting的顾客

```Pascal
var waiting:integer;
custormer,harbars,mutex:semphore
custormer := 0;
harbars := 0;
mutex := 1;
waiting := 0;
procedure harbar
begin
while (TRUE)
	begin
		P(customer);
		P(mutex);
		waiting := waiting - 1;
		V(harbar);
		V(mutex);
		理发
	end
end

procedure customer
begin
	P(mutex);
	if (waiting < n)then
	begin
		waiting := waiting + 1;
		V(customer);
		V(mutex);
		V(barbers);
		理发；
	end else V(mutex);
end
```

### 管程

#### 原因

信号量不利于资源的管理，发生无意的违法操作导致程序错误

#### 基本思想

把分散在各个进程中的**临界区**集中起来管理，把**共享资源**用数据结构抽象的表达出来

#### 构成

代表共享资源的数据结构及其上操作的一组过程

#### 本质

一种同步逻辑的封装机制

#### 基本结构

```
TYPE <管程名> = MONITOR(monitor xxxx)
<管程变量说明>(condition yy,zz)\
integer xxx;

procedure xxxx(para:type)
begin

end

endmonitor

```

#### 条件变量

调用管程的进程无法继续执行时，用于阻塞进程的信号量

#### 原语

##### wait

管程无法继续时，在某个条件变量上执行wait阻塞

##### signal

另一个进程执行signal，可以唤醒等待进程

#### 管程的互斥性

##### 执行signal的进程等待

##### 被释放的进程等待

### 管程的实现

#### Hoare方法

对应执行signal的进程等待的方法

##### 信号量

TYPE interf = RECOURD

###### mutex

互斥调用管程体

###### next

挂载发出signal的进程

###### x_sem

信号量 = 0（象征着某个等待条件）

##### 局部变量

###### next_count

挂载到next上的进程的个数

###### x_count

等在x_sem上的进程数

```Pascal
P(IM.mutex)
过程体（wait, signal）
if (IM.next_count > 0)
	V(IM.next);
else
	V(IM.mutex)

void wait(semaphore x_sem,int x_count, interf IM){
	x_count++;
	if (IM.next > 0)
		V(IM.next);
	else V(IM.mutex);
	P(x_sem);
	x_count--;
}

void signal(semaphore x_sem,int x_count, interf IM){
	if (x_count > 0){
		IM.next_count ++;
		V(x_sem);
		P(IM.next);
		IM.next_count--;
	}
}
```



#### Hanson方法

只允许在管程体的最后调用signal

### 管程解决实际问题

#### 生产者—消费者问题

```Pascal
monitor ProducerConsumer
	condition full, empty;
	integer count;
	
	procedure insert(item:integer)
	begin
		if count = N then wait (full)
		insert_item(item);
		count := count + 1;
		if count = 1 then signal(empty);
	end
	
	function remove:integer;
	begin
		if count = 0 then wait(empty);
		remove = remove_item;
		count := count - 1;
		if count = N - 1 then signal(full)
	end

	procedure producer;
	begin
		while true do
		begin
			item = produce_item;
			ProducerConConsumer.insert(item);
		end
	end
	
	procedure consumer;
	begin
		item = ProducerConsumer.remove;
		consume_item(item)
	end
```

#### 哲学家进餐问题

```
TYPE dining-philosophers = MONITOR
var state:array[0..4] of (thinking, hungry, eating);
	self:array[0..4] of condition;
define pickup, pickdown
use wait, signal;
procedure test(k:0..4)
begin
	if (state(k - 1)mod 5 != eating and state[k] = hungry and state(k + 1) mod 5 != eating ) then begin
    	state[(k + 1) mod 5] != eating) then begin
    		state[k] := eating;
    		signal(self[k]);
    	end
    end

procedure pickup(i:0..4)
begin
	state[i] = hungry;
	test(i);
	if (state[i] != eating) then wait(self[i]);
end

procedure pickdown(i:0..4)
begin
	state[i] := thinking;
	test((i - 1) mod 5);
	test((i + 1) mod 5);
end 

process
	thinking;
	pickup();
	eating();
	pickdown();

```

### 进程通讯

#### 原因

##### 信号量

解决进程同步和互斥问题

##### 数据

大量的数据交换

#### 常见的通信机制

##### 信号通信机制

["信号通信"](###信号机制)

##### 共享文件通信机制（管道通信）

引入特殊的管道共享文件

###### 管道

允许进程按照先入先出的方式传送数据，使得进程之间可以同步操作

###### 实现

1、文件机制

2、互斥访问

3、访问同步

4、通信双方知道对方的存在

###### 有名管道

管道机制只能连接有共同祖先的进程，而且有临时性

具有文件名，访问权限，是一般文件

##### 共享存储空间

最快捷，最有效（读写内存比磁盘快）

###### 过程

申请一个分区段，将分区段连接到进程的虚拟空间，可通过读写通信

#### 消息传递机制

##### 原语

###### send

###### receive

### 死锁

#### 死锁的产生

###### 独占资源

当一个进程需要**独占多个资源**

###### 进程并发

而操作系统允许多个**进程并发执行**共享系统资源时

###### 永远等待

可能会出现进程永远处于**等待状态**的现象

#### 死锁的产生因素

##### 资源

###### 资源数量

系统拥有资源的数量

###### 资源分配

资源分配的策略

##### 进程

###### 资源要求

进程对资源的需求

###### 进程同步

进程的推进速度

#### 死锁的定义

如果在一个**进程集合**中的每个进程都在等待只能由该集合中**其他一个进程才能引发的事件**，那么这一组进程或者系统发生了死锁

#### 死锁产生的四个条件

##### 互斥条件

临界资源互斥访问

##### 占有和等待条件

进程等待时不释放已占有的资源

##### 不剥夺条件

资源只能通过进程自愿释放，不可以剥夺

##### 循环等待条件

存在循环等待链

#### 常见的死锁防止方法

##### 静态分配方法

破坏第二个条件

##### 层次分配方法

破坏第四个条件

#### 死锁的避免

##### 资源轨迹图

执行的线索不允许经过同时拥有一个资源的区域，如果存在一条路径绕过这些区域就可以分配

##### 银行家算法

###### 前提条件

提供要求的最大资金量

提出资源需求和分配

有限事件归还

###### 判断依据

满足需求后，判断是否存在一个安全状态序列使得所有进程得到所需的最大资源

###### 数据结构

$$
Resource = (R_1,R_2,...,R_m);
$$

$$
Available = (V_1, V_2,...,V_m)
$$

$$
Claim = [C_{ij}...](C_{ij}表明进程i对资源j的最大需求量)
$$

$$
Allocation = [A_{ij}...](A_{ij}表明进程i已获得j类资源的个数)
$$



| 进程 | 当前未分配量 | 被分配的资源 | 返还后未分配的量 | 可分配性 |
| ---- | ------------ | ------------ | ---------------- | -------- |
| P0   | Available    | Aloocation   | Aval + Alloc     | T or F   |
|      |              |              |                  |          |

######  缺陷

信息——很难获取需要的资源总量

独立——各进程没有同步需求

静态——进程的数量和需求量是静态的

#### 死锁的检测和解除

##### 资源分配图

###### 节点

进程P~i~

资源R~j~

###### 边

申请边：P~i~->R~j~

分配边：R~j~->P~i~

##### 死锁的检测

###### 一个实例的资源

分配图存在环，那么死锁

###### 多个实例的资源

可以将其中对有多个实例的资源的请求边转换为分配边，如果一个进程的所有边转化为分配边那么可以化简去掉这些分配边，以此类推直到图为空图

##### 死锁的解除

###### 进程终止

###### 资源抢占

从别的进程中抢占资源

## 文件系统

### 概述

#### 出现

##### 操作复杂

用户直接操作和管理辅助存储器，复杂且容易出错

##### 更大容量

多道程序和分时系统的出现要求更加翻遍可靠的共享大容量辅助存储器

#### 定义

###### 操作系统

文件系统时操作系统中负责**存放和管理信息**的模块

###### 信息管理

它用统一的方式管理**用户**和**系统**信息的**存储、检索、更新、共享和保护**

###### 用户接口

并为用户提供一整套方便有效的**文件使用和操作方法**。

#### 功能

###### 按名存取

###### 文件目录

###### 逻辑文件到物理文件

###### 文件存储空间分配

###### 加密、保护和共享

###### 用户接口

### 文件

文件是由文件名字标识的一组信息的集合

#### 按名存取的优点

##### 易于管理

从复杂的物理存储地址管理中解放出来

##### 易于保护

方便对文件提供安全、保密和保护措施

##### 文件共享

实现文件共享

#### 文件的命名

###### 文件名

标识文件内容

###### 扩展名

标识文件特性

###### ？

任何一个符合要求的合法字符

###### *

任何一个合法的字符串

#### 文件的分类

##### UNIX文件类型

###### 普通文件

###### 目录文件

###### 设备文件

块设备文件，字符设备文件，有名管道文件，套接字文件

#### 文件的属性

###### 基本属性

文件名、所有者、授权者和长度

###### 类型属性

普通文件、目录文件、系统文件

###### 保护属性

读写，可执行，可更新，可删除

| 文件类型 | r      | w      | x      | r        | w        | x        | r        | w        | x        |
| -------- | ------ | ------ | ------ | -------- | -------- | -------- | -------- | -------- | -------- |
|          | 所有者 | 所有者 | 所有者 | 同组用户 | 同组用户 | 同组用户 | 其他用户 | 其他用户 | 其他用户 |

###### 管理属性

创建时间，最近存取时间

#### 文件的存取方法

用户文件通常使用前两种

##### 顺序存取

read/write

##### 直接存取

seek

##### 索引存取

了解操作系统内部结构，逻辑结构

数据库文件

#### 文件的使用

##### 操作或控制台命令

ls,mv,rm,cd

##### 系统调用

open,write

### 文件目录

#### 定义

文件系统建立和维护的关于系统所有文件的清单

#### 目录项（文件控制块）

对应一个文件的信息描述

##### 内容

###### 控制信息

文件名，存取权限

###### 结构信息

逻辑/物理结构

###### 使用信息

打开文件的进程数目

###### 管理信息

建立日期，访问日期

#### UNIX文件控制块

在目录文件仅存储filename和inode的映射块

在磁盘的固定区域存储inode节点（128bytes），存放文件控制块信息

| Filename 14bytes | inode 2bytes |
| ---------------- | ------------ |



#### 文件目录的结构

##### 一级目录结构

构造一张线性表，不包括任何子目录

容易发生重名

##### 二级目录结构

###### 主文件目录

管理用户文件目录

###### 用户文件目录

管理用户下的文件

##### 树形目录结构

倒置的有根树

###### 根目录

根为根目录

###### 子目录

树枝

###### 文件

树叶

###### 文件的全名

从根目录开始到文件名

目录路径+文件名

#### UNIX目录项建立方法

| 引导块     | 超级块   | 空闲空间管理                           | inode节点 | 根目录 | 文件和目录 |
| ---------- | -------- | -------------------------------------- | --------- | ------ | ---------- |
| bootloader | 统计信息 | 位示图标识空闲盘块（1bytes = 8 block） | FCB       |        |            |



### 按名存取的实现

查找目录文件，在目录文件中找到文件控制块

通过文件控制块从磁盘存取文件的内容

### 文件的组织和存储

#### 概念

##### 卷

物理存储介质的单位

i.e.一盘磁带，一张光盘

##### 块（物理记录）

**连续信息**组成的区域

###### 作用

主存储器和辅助存储器信息交换的单位

##### 逻辑记录

文件在逻辑上独立划分的信息单位

###### 作用

**应用程序处理的单位**

##### 存储记录

附加了控制信息的逻辑记录

###### 作用

是**管理程序处理的单位**

#### 三种记录的关系

用户记录映射到存储记录，存储记录由OS映射到物理记录

### 文件的结构

#### 逻辑结构

##### 定义

以用户的角度出发

###### 组织方式

在用户概念中的**抽象信息的组织方式**

###### 数据集合

以及用户可见并可处理的**数据集合**

##### 形式

###### 流式文件

一串信息集合

###### 记录式文件

包含逻辑记录

通过操作系统的成组和分解对应到一个物理记录上

#### 物理结构

##### 定义

文件在物理存储空间中的**存放方法**和**组织关系**

##### 构造方法

###### 计算法

设计算法映射过去

###### 指针法

设置指针

### 常见文件物理结构

#### 连续存储

##### 顺序文件

逻辑记录存储在存储介质的相邻物理块上

###### 缺点

不利于动态变化的逻辑记录

#### 非连续存储

##### 连接文件（串联文件）

使用连接字或指针表示文件割记录之间的串联关系

###### 特点

逻辑记录顺序独立于物理记录

修改方便

性能较低

###### FAT文件

目录项（FCB）->第一个物理块的索引->文件分配表->下一个物理块的索引->...->文件末尾

##### 直接文件（散列文件）

建立关键字和物理地址的映射关系（函数）

###### 以文件名或子目录名找到目录文件中对应目录项的物理地址

用哈希函数求出hash值A，A值相同的FCB可以存放在一个物理块

查找的时候定位物理块，在块内依次匹配

##### 索引文件

系统为每个文件建立**索引表**

| 记录键（逻辑记录号） | 块地址 |
| -------------------- | ------ |

###### 稀疏型索引

若干个物理块对应一个索引项，在项内采用顺序存储

###### 稠密型索引

每个物理块对应一个索引项

#### UNIX多重索引结构（混合索引结构）

##### 直接索引（10）

直接映射到对应的物理块

##### 一次间接（1）

存放了对应的索引表的物理块，索引表存储在一个物理块中

##### 二次间接（1）

##### 三次间接（1）

##### 作用

###### 固定大小

可以使得索引表为固定大小

###### 表达能力

使得可以表示很小/很大的文件

###### 读写效率

可以提高较小的文件的读写效率

### 文件操作

###### 文件系统提供的一组系统调用

#### 文件操作的实现

##### 磁盘结构（静态结构）

###### 超级块

###### inode区

###### 数据区

##### 数据结构（动态结构）

###### 进程已打开文件表——fd

文件描述符fd索引

###### 系统已打开文件表——fp

进程已打开文件表fp索引

###### 内存活动inode表——f_node

系统已打开文件表f_node索引

### 文件系统调用

#### 创建——create

```c
int fd, mode;
char *filemap;
fd = create(filenamap,mode);
```

##### 过程

###### inode节点

在磁盘分配inode节点

在内存分配活动inode节点，在活动索引节点赋初值

###### 目录项

建立新目录项插入到目录文件中

###### 已打开文件表

分配用户已打开文件表项和系统已打开文件表项

返回文件描述字fd

#### 删除——unlink

```c
unlink(filemap)
```

##### 要求

用户由**写操作权**

##### 过程

###### 目录项

将目录项从目录文件删除

###### inode节点

将i_link减一，如果为0，释放磁盘空间

#### 打开——open

```c
int fd, mode;
char * filemep;
fd = open(filemep,mode);
```

##### 过程

###### 目录

检索目录，将存索引节点复制到活动索引节点中

###### 参数mode

核对文件权限

###### 已打开表项

分配用户已打开表项和**系统已打开表项**

#### 关闭——fclose

```c
int fd;
close(fd);
```

##### 过程

###### 用户已打开表项

释放用户已打开表项

###### 系统已打开表项

将f_count减一，若为0释放表项

###### 活动inode节点

如果释放了系统已打开表项

i_count 减一，如果为0，将节点写回磁盘并释放节点

（否则强行关机可能导致磁盘信息不一致）

#### 读——read

```c
int nr, fd, count;
char buf[];
nr = read(fd, buf, count);
```

##### 过程

###### 权限

检查**系统已打开表项**f_flag检查操作是否合法

###### 物理地址

通过系统已打开表项的f_offset，需要读出的字节数以及**活动索引节点**的i_addr指出文件物理块地址，计算得到对应的物理块地址。

###### 读过程

读到缓存区中拷贝到用户空间

#### 写——write

```
nw = write(fd, buf, count);
```

#### 随机访问——lseek

```c
long lseek;
long offset;
int whence, fd;
lseek(fd, offset, whence)
```

##### 参数

###### 0

f_offset = offset

###### 1

f_offset += offset

#### 备份——dup

```c
int old_fd, new_fd;
new_fd = dup(old_fd);
```

##### 运用场景

###### 重定向

可以备份标准输入输出文件

关闭标准输入输出文件

将当前文件打开/备份到标准输入输出文件的fd上

##### 语义

在当前用户已打开表项选序号最小的项

### 文件共享

可以通过是否同一个filename来区分

#### 静态共享——用户

##### 链接（硬链接）

```c
char* oldnamep, *newnamep;
link(oldnamep, newnamep);
```

###### 实现

检索得到oldnamep文件的索引节点编号

检索目录得到newnamep文件的父目录文件

组成新的目录项加入目录文件

将对应的索引节点i_link++

##### 解除链接

```c
unlink(namep)
```

和删除文件共用

##### 符号链接共享（软链接）

一种只有文件名，不指向inode的文件

###### 优点

可跨文件系统

#### 动态共享——进程

多个进程并发访问同一文件

##### 使用同一位移指针

父进程和子进程用不同的fd得到相同的fp

在系统已打开文件表f_count = 2

共用同一个f_offset

##### 使用不同位移指针

进程A，B分别打开文件依次，创建两个系统已打开表项，指向一个活动inode节点并且i_count = 2

### 其他类型文件系统

#### 日志结构文件系统（将日志作为文件结构）

延迟写盘操作，增加了不一致风险，占用更多空间

集合一次文件变动所有的修改作为一个日志记录写回磁盘

i.e.log1,log2.....版本记录

#### 日志文件系统（有利于保证一致性）

增加可靠性

文件变动时，将涉及的操作记录下来

若成功，删除记录

否则根据日志记录恢复

#### 虚拟文件系统

##### 目标

###### 多种文件系统

###### 统一文件结构

###### 网络共享文件

###### 易于扩展

##### 思路

对多个文件系统的共同特征抽象，形成一个无关的虚拟层提供一致的接口

### 磁盘空间管理

#### 位示图



#### 成组空闲块链表

用额外的物理块存储空闲块的序号，用一个指针来把不同的物理块连接起来

##### 好处

可以动态调整空间，空闲块物理块少->数据块多

##### 缺点

额外的不必要的处理链表的操作

—>保持半满

### 物理块的尺寸

#### 大

I/O效率高

#### 小

利用率高

增加寻道时间，效率低

### 高速缓存管理

#### LRU

要考虑控制信息不能立即写回

### 文件系统备份

#### 方式

##### 物理备份

效率高，无法单独恢复某个文件

##### 逻辑备份

根据增量备份，可以恢复某个文件

### 一致性检查

突然掉电后产生不一致

##### 块一致性

检查使用信息和空闲信息

比如空闲位示图和inode节点统计数据

### 主存映射文件

将文件读写映射转换位内存访问

虚拟管理基础

#### 系统调用

mmap()

文件名，虚存地址

将文件映射道进程地址空间

ummap()

### 寻道时间优化

##### I-node节点位于连续的磁道上

##### 同一个文件的盘块在同一磁道上

### 块提前读

## 存储管理

### 定义

管理主存储器

### 主要内容

###### 分配和去配

主存储空间的分配和去配

###### 转换和保护

地址转换和存储保护

###### 共享

主存储空间共享

###### 扩充

主存储空间扩充

### 范围

主要针对用户内存空间的管理

### 存储器的层次

ps.虚拟存储管理（以次充好），用低成本的存储器实现高效的存储空间管理

| 寄存器         |
| -------------- |
| 高速缓存       |
| 主存储器       |
| 磁盘缓存       |
| 磁盘           |
| 可移动存储介质 |

### 地址转换

#### 目标代码

相对模块的逻辑地址

#### 可重定位程序

统一的逻辑地址

###### 静态连接

程序**装载前**链接：可重定位程序

###### 动态链接

程序**装载中**链接

###### 运行时链接

在执行到时链接

#### 可执行程序

###### 静态重定位

在**装载时**转化物理地址

###### 动态重定位

在**执行时**转化为物理地址（硬件支持，寄存器）

###### 运行时链接重定位

linux分页式管理

### 存储保护

防止操作系统和用户程序访问干扰

#### 存储保护硬件

###### 界地址

设定上下界

###### 存储键

存储块和p匹配

###### 页表

### 连续空间存储管理

#### 单用户连续存储管理（单分区模式）

##### 分区

系统区和用户区

##### 地址转换与存储保护

物理地址 = 界限地址 + 逻辑地址

###### 静态重定位

采用**栅栏寄存器**

###### 动态重定位

采用**定位寄存器**

#### 固定分区连续存储管理（定长分区/静态分区）

##### 适用场景

多道程序设计

##### 基本思想

给进入主存的作业划分一块连续存储区域

##### 实现

系统操作员静态的把主存空间分配给若干个连续的区域，位置固定

##### 缺点

容易出内碎片

##### 地址转换和存储保护

###### 静态定位方式

绝对地址是否落在分区

###### 动态定位方式

设置一对地址寄存器

##### 作业调度策略

选中一个能够装入最小分区的等待队列

##### 要求

适合已知程序大小和频率的情形

##### 缺陷

**无法预知**分区大小

主存**利用率**仍然较低

无法适应**动态**扩充主存

分区数目固定，限制**多道数量**

#### 可变分区连续存储管理

##### 基本思想

将作业的大小划分分区，划分动态确定

##### 主存分配表

存在已分配表和未分配表

##### 分区的合并——减少外碎片

在回收可变分区的过程中，将连续的空闲分区合并成更大的空闲分区

##### 可变存储管理算法

###### 最先适应（first fit）

###### 下次适应（next fit）

上次分配结束的位置开始查找

可以均衡分配，减少时间

###### 最先适应（best fit）

能放进去的最小分区

###### 最坏适应（worst fit）

能放进去的最大分区

###### 快速适应（quick fit）

每个分区排个队列

##### 地址转换与存储保护

###### 基址寄存器

###### 限长寄存器

#### 伙伴内存分配

将用户区域对半分割以实现最佳适应

##### 优点

外碎片少

方便合并

##### 缺点

内碎片

#### 连续内存管理的问题

内/外碎片

#### 连续存储管理技术

##### 移动技术

在找不到足够大的空闲区时，可以使用移动技术把在内存中的分区连接在一起（修改内存分配表和基址寄存器）

##### 对换技术

挂起技术

将阻塞的进程移动到磁盘上

从磁盘上读入一个程序

##### 覆盖技术

将大程序划分为一系列的覆盖，将不同时间装入内存的程序构成覆盖段，覆盖区由覆盖段里最大的覆盖决定

### 分页式存储管理

#### 概念

##### 页框（块）

物理地址划分

ps.实时系统中页表访问的时间不可估计，不采用

##### 页面

逻辑地址划分，大小和页框相等

##### 逻辑地址形式

| 页号 | 单元号 |
| ---- | ------ |

##### 地址转换

###### 物理地址

页框号 * 块长 + 单元号

###### 逻辑地址

页号 * 页长 + 单元号

#### 相联存储器&快表

存放最近访问的部分页表

| 页号 | 页框号 | 特征位 | ...  |
| ---- | ------ | ------ | ---- |

#### 多级页表

##### 作用

可以部分的存放在内存中

不会减少总量，但可以不连续存取

##### 过程

二级页表范文一次地址访问三次主存

页目录->页表->数据

#### 反置页表

块号->页号

仅保存调入内存的页框信息

使用进程标识和页号哈希到反置页表，如果不匹配，遍历哈希链

#### 地址转换过程

页目录控制寄存器 + 页目录号 = 一级页表地址

页表地址 + 页表偏移量 = 物理页框号

#### 页面共享

代码共享时需要约定统一的页号

在父进程fork得到子进程的情况下实现

#### 页面保护

##### 标志位法

在页表添加标志位信息

##### 存储保护键

进程和页表匹配

### 分段式存储管理

#### 目标

提高主存的利用率

方便以模块为单位的装配，共享和保护

#### 逻辑地址

段号+ 段内地址

#### 段表

| 始址 | 长度 |
| ---- | ---- |

#### 作业表

| 作业名 | 段表始地址 | 段表长度 |
| ------ | ---------- | -------- |

#### 段共享

不同作业中指向同一个段基址

### 分段vs分页

#### 分段

##### 逻辑单位

由源程序的逻辑结构决定

##### 用户可见

用户可见，并由用户决定段长

##### 任意位置

段起始地址可以任意开始

#### 分页

##### 物理单位

由硬件决定

##### 用户不可见

硬件提供页大小

##### 固定位置

页面只能从页大小的整数倍开始

### 虚拟存储管理

将当前的部分程序/数据装入主存

#### 内容

##### 部分装入

##### 部分对换

##### 依据

###### 空间局部性

###### 时间局部性

#### 优点

##### 拓展空间

作业的内存空间可以大于实际的内存空间

##### 利用率高

##### 用户透明

#### 虚拟存储器

在具有**层次结构存储器**的计算机系统中

采用**自动实现部分装入和部分对换**的功能

为用户提供一个**比物理主存容量大得多的可寻址**的寄存器

#### 虚拟存储vs对换技术

##### 处理单位

页/段

进程

##### 主存空间

可以处理主存容量大于空闲量

不可以处理主存大于空闲的情况

#### 常见的虚拟式存储管理技术

##### 请求分页式存储管理

将作业划分为页面存放在辅助存储器中，只装入访问和使用的页面

##### 内容

###### 创建

创建页表

分配磁盘交换区

初始化页表

修改PCB

###### 执行

设置页表基址寄存器

###### 异常

页面加载和替换

###### 终止

释放页框

释放页表

释放磁盘交换区

##### 页表项

###### 引用位

###### 修改位

###### 保护位

##### 硬件支撑

主存管理单元MMU

###### 功能

逻辑地址->物理地址

缺页中断/越界中断

###### 组成

页表基址寄存器

快表TLB

#### 页面装入策略

##### 请页式调入

中断驱动

###### 预调式调入

按某种预测算法动态预测并调入

##### 消除策略

###### 请页式清除

替换和清除成对完成

###### 预约式清除

成批在替换之前写回

###### 页缓冲技术

维护修改页面队列和非修改页面队列

修改页面不断写出进入非修改页面

替换采用非修改页面中的页面

#### 页面分配策略

##### 问题

###### 分配多少

少——进程多

多——中断率高

###### 如何分配

替换算法全局/局部

##### 固定分配

平均、按比例、优先权

##### 可变

缺页较多分配较多的页框

#### 页面替换策略

##### 局部替换——固定分配

##### 全局替换——可变分配

#### 缺页率

缺页次数 / 总访问次数

##### 影响因素

###### 替换算法

###### 页框数

###### 页面大小

###### 程序特性

#### 最佳页面尺寸

512B~8KB

减少碎片和页表占用的空间

p：页面大小

s：进程大小

e:页表项大小

计算浪费空间大小
$$
f(p) = se /p + p/2
$$

##### 

#### 实现中的技术

##### 页面交换区/交换文件

磁盘区域，交换区映射表

##### 锁定内存页

某些页面不允许替换

##### 写时复制

可以允许多个进程访问同一份资源

只有在写时才创建副本



##### 请求分段式存储管理

##### 请求段页式存储管理

###### 优势

段式管理：模块化管理，但浪费空间

页式管理：提高利用率

###### 实现原理

虚地址划分段->线性地址

实地址划分页->物理地址

线性地址划分为页面

### 典型的局部页面替换算法

#### 最佳页面替换算法

不再访问的页

距现在最长时间后访问的页

#### 随机页面替换算法

随机数

#### 先进先出替换算法

淘汰最先调入主存的页面

适合线性特征的程序

#### Belady异常

增加内存未必可以改善其性能

#### 第二次机会页面替换算法

FIFO基础上检查页面的引用位

0：清除

1：清0，并且放在队列尾部

#### 时钟页面替换算法

第二次机会页面替换算法的环形队列版本

0：清除

1：指针移动到下一个

#### 时钟页面替换算法的改进

结合修改位

第一次循环寻找r = 0并且m = 0，不修改引用位

第二次循环寻找r = 0并且m = 1，修改引用位

结束后所有r = 0，返回第一步

#### 最近最少使用页面替换算法

淘汰最近一段时间里较久未被访问的页面

##### 实现

###### 淘汰队列

维护一个淘汰队列，队尾总是指向最近访问的页面

###### 标志位

###### 多位计数器

###### 多位寄存器

老化算法

###### 多位计时器

添加时间戳

### 典型的全局页面替换算法

#### 全局最佳页面替换算法

如果在t时刻发生缺页将页面装入页框

如果在给定的T

(T  + t)内未引用移除页面

#### 工作集模型

##### 定义

使得每个进程每一时刻可以执行下去，在物理存储器必须有的最少页面集合

#### 工作集替换算法

如果在t缺页装入页框

给定T

如果页面在时间间隔(t - T)未被应用移除页面（出现了在T个回合没有访问）

##### 老化算法实现

1000->0100->0010->0001

移除工作集

##### 时间戳

r = 1,清空时间戳

r = 0,当前时间 - 时间戳 = t_off

t_off > t_max移除

#### 缺页频率替换算法

记录临界值T

如果两次缺页的时间差超过了T，那么这个期间内没有应用的页面全部清除出工作集

## 设备管理

### 计算机的外围设备

#### 存储型设备

磁带机，磁盘机

#### 输入输出型设备

显示器，卡片机，打印机

### 设备管理的目标

###### 方便使用

方便用户使用各种各样的外部设备

###### 并行执行

提高设备的并行性

###### 利用效率

提高利用效率

### 输入/输出处理

#### 组成

主存和外围设备的输入输出

##### 硬件

###### I/O设备及接口电路

###### 控制部件

###### 通道

##### 软件

###### 管理软件

#### 分类

##### 输入/输出特征

输入型、输出型、存储型

##### 信息交换的单位

字符型

块型

##### 存取方式

顺序型

随机存取方式

#### I/O控制器

实现cpu和机械设备之间，cpu通过控制器控制机械设备输入输出

#### 输入/输出的控制方式

##### 询问方式

###### 忙式等待

cpu查询外围设备状态

###### 串行工作

cpu和I/O设备

###### 效率低下

##### 中断方式

##### DMA方式

I/O设备和主存直接交换数据

DMA具有处理器的能力

DMA具有总线控制权

数据以块传输

不需要CPU时间并行工作

CPU需要干预块与块之间的操作

##### 通道方式

免除了CPU对快与块的干预

只需要在启动时执行指令，结束时中断通知执行结束

完全并行国祚

#### I/O软件

##### 设备独立性

文件系统命名

##### 出错处理

错误尽量在接近硬件层得到处理

##### 同步和异步

##### 缓冲

##### 设备的分配与去配

#### I/O软件的层次

| 用户级I/O   | 系统调用、格式化、Spooling         |
| ----------- | ---------------------------------- |
| 设备无关I/O | 命名，保护，阻塞，缓存，分配，跟踪 |
| 设备驱动    | 设置寄存器初值，启动I/O检查状态    |
| 中断处理    | 处理I/O，报告错误，唤醒驱动        |
| I/O硬件     | 执行I/O                            |

#### 中断处理程序

##### 功能——唤醒设备驱动程序

保护现场

提供设备驱动程序环境

唤醒设备驱动

返回

#### 设备驱动程序

直接控制I/O设备

##### 功能

设备初始化

将抽象读写转化为I/O请求

阻塞等待中断处理程序唤醒

#### 与设备无关的I/O

I/O设备命名和保护

定义块大小

缓存管理

设备分配和跟踪

错误处理与报告

#### 用户I/O软件

##### 库函数

系统调用，格式化

##### 独立进程

假脱机系统

在磁盘开辟一块空间，将低速输入的数据由单独的单独的进程存储在空间内，在I/O请求时和磁盘进行数据交换。

### 缓冲技术

###### 速度协调

解决CPU和外围设备不匹配的矛盾

###### 物理/逻辑记录

协调物理记录和逻辑记录

###### 中断频率

减少中断次数

###### 响应时间

放宽响应时间

#### 分类

##### 单缓存

##### 双缓存

缓存交换，轮流工作   

##### 多缓存

管程，共享

### 驱动调度

多个进程访问辅助存储器

#### 影响因素

##### 调度算法

##### 排列方式

##### 分配方法

存储空间的分配方法

### 存储设备的物理结构

#### 顺序存取

磁带机

存储容量大，稳定可靠

用于存档文件

#### 随机存取——磁盘

##### 参数

###### 柱面号（10bits）

###### 磁头号（8bits）

###### 扇区号（6bits）

一个盘面上所有磁头的轨道为磁道（一个一个同心圆），一个磁道可以划分为多个扇区

硬盘的容量=柱面数(CYLINDER)*磁头数(HEAD)*扇区数(SECTOR)*512B

###### 容量

要注意扇区号从1开始，柱面和磁头从0开始

##### 结构

| 前导码 | 数据块 | 错误校验码 |
| ------ | ------ | ---------- |

### 旋转型设备的访问优化

#### 循环排序

注意不知道起始位置的话需要1/2的时间对准扇区

#### 优化分布

考虑处理时间，在处理结束之后刚好读取到下一个需要的扇区

#### 交替地址

通过数据的冗余存放提高访问速度

##### 优点

一致性

##### 缺点

冗余，效率低

### 旋转型设备移动臂调度算法

#### 最短时间优先调度算法

#### 电梯调度算法

总是向着某个方向移动

### 考虑磁道循环排序和移动臂

先考虑柱面（因为机械臂时间长）

在柱面上归并同一个磁头

最后考虑扇区

