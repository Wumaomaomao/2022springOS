# 《操作系统》课程第五章课后作业

计算机科学与技术系 201220102 武雅琛



**1、For each of the following decimal virtual addresses, compute the virtual page number and offset for a 4-KB page and for an 8 KB page: 20000,  32768, 60000.**

+ 4KB = 2^12^bytes，8KB = 2^13^bytes

+ 那么取虚拟地址的低12/13位即为对应的页内偏移量

  将虚拟地址做向右的移位运算12/13位可以得到对应的虚页号

+ 计算结果

  4KB页面

  |             | 20000 | 32768 | 60000 |
  | ----------- | ----- | ----- | ----- |
  | offset      | 3616  | 0     | 2656  |
  | page number | 4     | 8     | 14    |

  8KB页面

  |             | 20000 | 32768 | 60000 |
  | ----------- | ----- | ----- | ----- |
  | offset      | 3616  | 0     | 2656  |
  | page number | 2     | 4     | 7     |

**2、You are given the following data about a virtual memory system:**

- The TLB can hold 1024 entries and can be accessed in 1 clock cycle (1 nsec). 
- A page table entry can be found in 100 clock cycles or 100 nsec.
- The average page replacement time is 6 msec.

**If page references are handled by the TLB 99% of the time, and only  0.01% lead to a page fault, what is the effective address-translation  time?**

虚拟地址转换时间 = 快表直接地址转换 + 查找内存空间页表地址转换 + 缺页处理和外部存储交换虚页。

列出算式如下：
$$
0.99 \times 1 + 0.0001 \times 6000000 + (0.01 - 0.0001) \times 100 = 601.98 \ clockcycle(nsec)
$$
**3、A computer has 32-bit virtual addresses and 4-KB pages. The program and  data together fit in the lowest page (0–4095) The stack fits in the  highest page. **

**How many entries are needed in the page table if  traditional (one-level) paging is used? **

+ 4-KB = 2^12^

+ 相当于32位地址的低十二位将作为页内偏移量，高二十位作为虚页号。

+ 总共存在页表项：
  $$
  2^{20} = 1M = 1,048,576\ entries
  $$
  

**How many page table entries are  needed for two-level paging, with 10 bits in each part?**

+ 此时32位虚拟地址高10位作为页目录表表项序号，接下来的10位作为页表表项序号。

+ 存在页目录项：
  $$
  2^{10} = 1K = 1024 \ entries
  $$

+ 每张页表内的表项：
  $$
  2^{10} = 1K = 1024 \ entries
  $$
  
+ 总共存在页表项：
  $$
  2^{10} \times 2^{10} = 1M = 1,048,576\ entries
  $$

**4、Below is an execution trace of a program fragment for a computer with 512-byte pages. The program is located at address 1020, and its stack  pointer is at 8192 (the stack grows toward 0). Give the page reference  string generated by this program. Each instruction occupies 4 bytes (1  word) including immediate constants. Both instruction and data  references count in the reference string.**

1. **Load word 6144 into register 0**

   | 操作                      | 虚页号 |
   | ------------------------- | ------ |
   | 访问内存6144              | 12     |
   | 访问指令代码区域1020~1023 | 2      |

2. **Push register 0 onto the stack**

   | 操作                      | 虚页号 |
   | ------------------------- | ------ |
   | 访问栈区8188~8191         | 15     |
   | 访问指令代码区域1024~1027 | 3      |

3. **Call a procedure at 5120, stacking the return address **

   | 操作                      | 虚页号 |
   | ------------------------- | ------ |
   | 访问栈区8185~8188         | 15     |
   | 访问指令代码区域1028~1031 | 3      |
   
4. **Subtract the immediate constant 16 from the stack pointer** 

   | 操作                      | 虚页号 |
   | ------------------------- | ------ |
   | 访问指令代码区域5120~5123 | 10     |

5. **Compare the actual parameter to the immediate constant 4 **

   | 操作                              | 虚页号 |
   | --------------------------------- | ------ |
   | 访问栈区8188~8191（取出实际参数） | 15     |
   | 访问指令代码区域5124~5127         | 10     |

6. **Jump if equal to 5152**

   | 操作                      | 虚页号 |
   | ------------------------- | ------ |
   | 访问指令代码区域5128~5131 | 10     |



**5、Suppose that the WSClock page replacement algorithm uses a τ of two ticks, and the system state is the following: **   

[![p5.png](http://114.212.80.195:8170/media/cache/7a/f3/7af3af7b2d4af36ff3f9660571371889.jpg)](http://114.212.80.195:8170/media/wiki/images/39/26a9e3a90f76459f8a01a53489bffb9f/p5.png)

where the three flag bits V, R, and M stand for Valid, Referenced, and Modified, respectively.

- **If a clock interrupt occurs at tick 10, show the contents of the new table entries. Explain. (You can omit entries that are unchanged.)**

  在发生一次时钟中断时,WSClock替换算法会**清空在上一个周期内硬件写入的R位**并且对于R == 1的表项**刷新时间戳**记录上一次被引用的时间，所以第一项和第二项的R位将被清零，时间戳修改为10。

  

- **Suppose that instead of a clock interrupt, a page fault occurs at  tick 10 due to a read request to page 4. Show the contents of the new  table entries. Explain. (You can omit entries that are unchanged.)**

  可以看到page 4不在页表中，所以需要在内存中使用替换算法替换掉一个页面。

  而page 3在**最近一个周期没有被引用R == 0**，**未被修改M == 0并且上次引用到当前的时间最长**，选择它进行替换。

  结果为修改page 3的V位为0

  将page 4的V位置1，R位置1，时间戳记录为当前引用时间：10

**6、A computer has four page frames. The time of loading, time of last  access, and the R and M bits for each page are as shown below (the times are in clock ticks):  **
    

[![p6.png](http://114.212.80.195:8170/media/cache/36/e0/36e0bdfe8a6bcb0b250b2c044689cbbe.jpg)](http://114.212.80.195:8170/media/wiki/images/39/6c1dec8e52c04c54b9604a96dd871328/p6.png)

1. **Which page will NRU replace?**

   Page 2(最近未被引用)

2. **Which page will FIFO replace?**

   Page 3

3. **Which page will LRU replace?**

   Page 1(最近最少用)

4. **Which page will second chance replace?**

   Page 2

   （因为page 3满足FIFO但是结合R位最近被引用过顺延到Page 2）

   

7、**Consider the following two-dimensional array:** 

```C
int X[64][64];
```

Suppose that a system has **four page frames** and **each frame is 128  words (an integer occupies one word)**. Programs that manipulate the X  array fit into exactly one page and always occupy page 0. The data are  swapped in and out of the other three frames. The X array is stored in  row-major order (i.e., X[0][1] follows X[0][0] in memory). Which of the  two code fragments shown below will generate the lowest number of page  faults? Explain and compute the total number of page faults.

[![p7.png](http://114.212.80.195:8170/media/cache/ea/89/ea8908161b89611bd5a502cf62bb2fb7.jpg)](http://114.212.80.195:8170/media/wiki/images/39/b3c61e29dcd0458cab6026cee90ccf9b/p7.png)



+ Fragment B

因为数组内的元素是按照行优先的原则在存储空间里排列的，B方法更能充分利用数据存储方式的特点。

A方法会发生32*64 = 2048次缺页（每次读完两个元素就要从外存读入一个新的页面）

B方法只会发生32次缺页
